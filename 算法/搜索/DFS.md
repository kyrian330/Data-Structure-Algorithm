### 深搜——不撞南墙不回头



#### 举例

##### 1.放牌

将编号1、2、3的扑克牌放到编号为1、2、3的三个盒子，每个盒子只能放一张牌，求一个有多少种放置方法。



- 第一次尝试

​		星队走到1号盒子前，放入1号牌；走到2号盒子，放2号牌；走到3号盒子前，放3号牌。走到4号盒子，发现没盒子也没有牌，说明已经完成了一种序列 1 2 3。

- 第二次尝试

​		星队返回3号盒子前，取出3号牌，但目前无法再放入3号盒子，不然和上一个序列1 2 3相同了；所以星队回到2号盒子前，取出2号牌，这时星队手里有两张牌，并将3号放进2盒，2号放进3盒，又来到4号盒子(无)，此时又生成新的序列 1 3 2。

- 第N次尝试

​		会得出剩下的序列 2 1 3、2 3 1、3 1 2、3 2 1。

[^]: 于是每个盒子都曾放入1 2 3号牌，其实就是将全排列问题形象化。



#### 思路

如何用程序实现上述步骤？

- 如何将牌放入当前盒子？

​		用数组a表示盒子，变量step表示正处在第step个盒子面前。a[step] = i，表示将i号牌放入第step个盒子里。放入盒子的牌当前无法再放入其他盒子，所以用数组book标记用过的牌。

```c
void dfs(int step) {  // step表示正处在第step个盒子面前
    
    for (int i = 1; i <= n; i++) {

        if (book[i] == 0) {    // book[i] == 0说明牌还在手上
            a[step] = i;      // 将 i号牌放入第 step个盒子里
            book[i] = 1;      // 标记 i号牌, 说明牌已经不在手上
        }
    }
}
```



- 如何处理下一个盒子？

​		处理完第step个盒子后，处理下一个盒子，就是第step+1个盒子，处理方法和刚才一样，调用函数dfs(step+1)。

```c
void dfs(int step) {  // step表示正处在第step个盒子面前

    for (int i = 1; i <= n; i++) {

        if (book[i] == 0) {    // book[i] == 0说明牌还在手上
            a[step] = i;      // 将 i号牌放入第 step个盒子里
            book[i] = 1;      // 标记 i号牌, 说明牌已经不在手上

            dfs(step + 1);    // 函数递归, 调用自己
            book[i] = 0;     // 这一步非常重要, 一定要将刚才放入的牌收回, 才能进行下一次尝试
        }
        return;
    }
}
```



- 如何输出？

​		处理第n+1个盒子的时候，对面前n个盒子已经放好牌，所以可将1~n个盒子里的牌打印出来。注意，打印完毕要立即return，不然程序会无限运行。（详情请看完整代码）



#### 完整代码

```c
#include <stdio.h>
int a[10], book[10], n;    // 特别说明一下: C语言全局变量没有赋值前默认为0,
                          // 所以book数组无需全部赋初始值0.

/*
 * @描述: 深度优先搜索（以发牌举例）
 * @作者: 星队
 * @创建时间: 2022/10/10 17:41
 */
void dfs(int step) {  // step表示正处在第step个盒子面前

    int i;
    if (step == n + 1) {    // 如果站在第 n+1个盒子面前, 则表示前 n个盒子已经放好牌

        // 输出1~n号盒子的牌号
        for (i = 1;  i <= n ; i++)
            printf("%d", a[i]);
        printf("\n");

        return;    // 返回之前的一步(最近一次调用dfs函数的地方)
    }


    // 此时站在第 step个盒子面前
    for (i = 1; i <= n; i++) {    // 为了便与理解, 从1开始索引

        if (book[i] == 0) {    // book[i] == 0说明 i号牌还在手上
            a[step] = i;      // 将 i号牌放入第 step个盒子里
            book[i] = 1;      // 标记 i号牌, 说明牌已经不在手上

            // 第 step个盒子已经放好, 星队走到下一个盒子面前
            dfs(step + 1);    // 函数递归, 调用自己
            book[i] = 0;     // 这一步非常重要, 一定要将刚才放入的牌收回, 才能进行下一次尝试
        }
    }

    return;
}


int main() {

    printf("请输入一个 1~9之间的整数");
    scanf("%d", &n);
    dfs(1);    // 首先站到第一个盒子前
    return 0;
}
```

简单的例子，核心代码不超过20行，却饱含深度优先搜索的基本模型。



#### 拓展例题

##### 1.奥数

​		xxx + xxx = xxx。x号代表 1~9的某一个数字，每个数字只能用一次使得等式成立，例如173 + 286 = 459就是一个可行的组合，请问有多少种组合？注意：173 + 286 = 459 和 286+ 173 = 459只能算一种组合。可用暴力枚举，但是计算量太大（9层循环），请尝试其他方法。



- 思路

​		在9的全排列找到 a[1] * 100 + a[2] * 10 + a[3] + a[4] * 100 + a[5] * 10 + a[6] = a[7] * 100 + a[8] * 10 + a[9]则为一个可行的组合。(可观察上一个深搜模型的输出，每个位数都可能出现任何数字)



- 完整代码

```c
#include <stdio.h>
int a[10], book[10], total;


void dfs(int step) {

    int i;
    if (step == 10) {    // 如果站在第 10个盒子面前, 则表示前 9个盒子已经准备就绪

        if (a[1] * 100 + a[2] * 10 + a[3] + a[4] * 100 + a[5] * 10 + a[6] == a[7] * 100 + a[8] * 10 + a[9]) {
            total ++;
            printf("%d%d%d + %d%d%d = %d%d%d\n", a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9]);
        }
        return;
    }

    // 按照1 ~ 9逐个尝试
    for (i = 1; i <= 9; ++i) {

        if (book[i] == 0) {
            a[step] = i;
            book[i] = 1;

            dfs(step + 1);
            book[i] = 0;
        }
    }

    return;
}


int main() {

    dfs(1);
    printf("total = %d", total / 2);
    return 0;
}
```





##### 2.迷宫

​		星队在迷宫里迷路了(迷宫由若干个单元格构成，每个单元格要么是空地，要么是障碍物)，假设你拿到了地图，他正在原地等你去引路。注意：你不能跨越障碍物，也不能走到迷宫之外，而且要找出一条最短路径。

```
0 0 1 0
0 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1

迷宫地图如上，1为障碍物，0空地。注意：为了方便理解，所以都是从1开始索引的，例如最左上的数字0的坐标是(1, 1)。
```



- 思路

​		我们尝试用**深搜**来实现这个过程。dfs()函数的功能是解决当前应该怎么办，对于搜索者在某个坐标要处理的是：先检查自身是否到了星队的位置，如果没到则需找出下一步可以走的地方。所以dfs()函数需维护3个参数，分别是当前这个点的行坐标(row)、列坐标(column)、当前走过的步数(step)。



- 判断是否达到星队的位置，假设星队位置为(p , q)。

```c
void dfs(int row, int column, int step) {

    // 判断坐标是否相等
    if (row == p && column == q) {
        
        // 更新路径的最小值
        if (step < min)
            min = step;
        return;    // 注意这里的返回非常重要
    }

    return;
}
```



- 如果未到达星队的位置，向四个方向尝试

```c
// 为了统一, 我们按照顺时针尝试(按照向 右、下、左、上顺序尝试)。且定义一个方向数组next, 方便编码。

int next [4][2] = {
    {0, 1},    // 向右走(列 + 1)
    {1, 0},    // 向下走(row + 1)
    {0, -1},    // 向左走(column - 1)
    {-1, 0}};    // 向上走(row - 1)

// 通过这个方程组，我们使用循环很容易获得下一步的坐标。设下一步横坐标为t_row，纵坐标为t_column。
```



![4](img\万能的搜索\4.png)





```c
// 枚举四种走法
for (k = 0; k <= 3; k++) {
    
    // 计算下一个点的坐标
    t_row = row + next[k][0];
    t_column = column + next[k][1];
}
```



- 判断下一个点

​		接下来要对点(t_row，t_column)进行判断，例如是否越界，是否为障碍物，以及这个点是否在路径中(避免重复访问一个点)。所以用一个book[t_row] [t_column]数组来记录当前点(t_row，t_column)是否在路径里。

```c
// 枚举四种走法
for (k = 0; k <=3 ; ++k) {


    // 计算下一个点的坐标
    t_row = row + next[k][0];
    t_column = column + next[k][1];

    // 判断越界, 此时情况已越界,继续判断下一个点
    if (t_row < 1 || t_row > n || t_column < 1 || t_column > m)
        continue;

    // 判断该当前点是否为 障碍物 或者 已在路径中
    if (a[t_row][t_column] != 1 && book[t_row][t_column] != 1) {

        book[t_row][t_column] = 1;    // 标记已走过的点
        dfs(t_row, t_column, step + 1);    // 开始尝试下一个点
        book[t_row][t_column] = 0;    // 尝试结束, 取消这个点的标记
    }
}
```





- 完整代码

```c
#include <stdio.h>
int a[51][51], book[51][51];
int n = 5, m = 4, p, q, min = 99999;    // 迷宫有 n行, m列。星队被困坐标为(p , q)

void dfs(int row, int column, int step) {

    // 判断是否到达星队的位置
    if (row == p && column == q) {
        
        if (step < min)
            min = step;
        return;
    }

    // 方向数组
    int next [4][2] = {
                        {0, 1},    // 向右走(列 + 1)
                        {1, 0},    // 向下走(row + 1)
                        {0, -1},    // 向左走(column - 1)
                        {-1, 0}};    // 向上走(row - 1)


    int k, t_row, t_column;    // 设下一个点的坐标为(t_row, t_column)
    // 枚举四种走法
    for (k = 0; k <=3 ; ++k) {


        // 计算下一个点的坐标
        t_row = row + next[k][0];
        t_column = column + next[k][1];

        // 判断是否越界
        if (t_row < 1 || t_row > n || t_column < 1 || t_column > m)
            continue;

        // 判断该点是否可走
        if (a[t_row][t_column] != 1 && book[t_row][t_column] != 1) {

            book[t_row][t_column] = 1;
            dfs(t_row, t_column, step + 1);
            book[t_row][t_column] = 0;
        }
    }

    return ;
}


int main() {

    int i, j, start_row, start_column;

    printf("请输入 n行, m列的迷宫(n <= 50, m <= 50)\n");
    scanf("%d %d", &n, &m);

    printf("请写入迷宫图\n");
    /**
        0 0 1 0
        0 0 0 0
        0 0 1 0
        0 1 0 0
        0 0 0 1
    **/
    for (int i = 1; i <=n ; ++i)    // 行和列都是从1开始索引
        for (int j = 1; j <= m ; ++j)
            scanf("%d", &a[i][j]);


    printf("请输入起点和终点坐标\n");
    scanf("%d %d %d %d", &start_row, &start_column, &p, &q);

    // 从起点开始搜索
    book[start_row][start_column] = 1;    // 先标记
    dfs(start_row, start_column, 0);    // 初始步数为0

    printf("最短步数是 %d", min);
    return 0;
}
```



- 结果

```c
请输入 n行, m列的迷宫(n <= 50, m <= 50)
5 4
请写入迷宫图
        0 0 1 0
        0 0 0 0
        0 0 1 0
        0 1 0 0
        0 0 0 1
请输入起点和终点坐标
1 1 4 3
最短步数是 7
```



